obs_2 <- Observation$new(data = energy, n_states = n_states, dists = dists,
par = pars, formulas = formulas_2)
### Get penalty matrices from Observation object
obs_mats_1 <- obs_1$make_mat()  ### get all matrices
S_1 <- obs_mats_1$S_list[[1]]   ### just get first penalty matrix
obs_mats_2 <- obs_2$make_mat()  ### get all matrices
S_2 <- obs_mats_2$S_list[[1]]   ### just get first penalty matrix
print(det(S_1)) ### should be non-zero
print(det(S_2)) ### should be zero
### lightweight script to fit hmmTMB
### on the energy dataset
library(hmmTMB)  ## requires first installing from github
library(MSwM)    ## package for data
data(energy)     ## load data
n_states <- 2    ## 2 states for now
### Create MarkovChain object
### Assume stationary distribution
hid <- MarkovChain$new(data = energy,
n_states = n_states,
stationary = TRUE)
### We want to model "Price" as a Gaussian,
### Parameters are mean and sd. There are
### over 20 named dists. to choose from.
### You could model more observed variables
### by adding them to the list.
dists <- list(Price = "norm")
### Difference order 1 and 2
formulas_1 <- list(Price = list(mean = ~s(Oil, k = 5, bs = "ps", m = c(2,1)),
sd = ~s(Oil, k = 5, bs = "ps", m = c(2,1))))
formulas_2 <- list(Price = list(mean = ~s(Oil, k = 5, bs = "ps", m = c(2,2)),
sd = ~s(Oil, k = 5, bs = "ps", m = c(2,2))))
### Nested list of initial parameters
### of fixed effects/observation models.
pars <- list(Price = list(mean = rep(0, n_states), sd = rep(1, n_states)))
### Create observation models
obs_1 <- Observation$new(data = energy, n_states = n_states, dists = dists,
par = pars, formulas = formulas_1)
obs_2 <- Observation$new(data = energy, n_states = n_states, dists = dists,
par = pars, formulas = formulas_2)
### Get penalty matrices from Observation object
obs_mats_1 <- obs_1$make_mat()  ### get all matrices
S_1 <- obs_mats_1$S_list[[1]]   ### just get first penalty matrix
obs_mats_2 <- obs_2$make_mat()  ### get all matrices
S_2 <- obs_mats_2$S_list[[1]]   ### just get first penalty matrix
print(det(S_1)) ### should be non-zero
print(det(S_2)) ### should be zero
### lightweight script to fit hmmTMB
### on the energy dataset
library(hmmTMB)  ## requires first installing from github
library(MSwM)    ## package for data
data(energy)     ## load data
n_states <- 2    ## 2 states for now
### Create MarkovChain object
### Assume stationary distribution
hid <- MarkovChain$new(data = energy,
n_states = n_states,
stationary = TRUE)
### We want to model "Price" as a Gaussian,
### Parameters are mean and sd. There are
### over 20 named dists. to choose from.
### You could model more observed variables
### by adding them to the list.
dists <- list(Price = "norm")
### Difference order 1 and 2
formulas_1 <- list(Price = list(mean = ~s(Oil, k = 5, bs = "ps", m = c(2,1)),
sd = ~s(Oil, k = 5, bs = "ps", m = c(2,1))))
formulas_2 <- list(Price = list(mean = ~s(Oil, k = 5, bs = "ps", m = c(2,2)),
sd = ~s(Oil, k = 5, bs = "ps", m = c(2,2))))
### Nested list of initial parameters
### of fixed effects/observation models.
pars <- list(Price = list(mean = rep(0, n_states), sd = rep(1, n_states)))
### Create observation models
obs_1 <- Observation$new(data = energy, n_states = n_states, dists = dists,
par = pars, formulas = formulas_1)
obs_2 <- Observation$new(data = energy, n_states = n_states, dists = dists,
par = pars, formulas = formulas_2)
### Get penalty matrices from Observation object
obs_mats_1 <- obs_1$make_mat()  ### get all matrices
S_1 <- obs_mats_1$S_list[[1]]   ### just get first penalty matrix
obs_mats_2 <- obs_2$make_mat()  ### get all matrices
S_2 <- obs_mats_2$S_list[[1]]   ### just get first penalty matrix
print(det(S_1)) ### should be non-zero
print(det(S_2)) ### should be zero
library(hmmTMB)  ## requires first installing from github
library(MSwM)    ## package for data
data(energy)     ## load data
gam_setup <- gam(Energy ~ s(Oil, k = 6, bs = "ps", m = c(2,1)), fit = FALSE)
gam_setup <- gam(Energy ~ s(Oil, k = 6, bs = "ps", m = c(2,1)), data = energy, fit = FALSE)
gam_setup <- gam(Price ~ s(Oil, k = 6, bs = "ps", m = c(2,1)), data = energy, fit = FALSE)
gam_setup$S
gam_setup$X
dim(gam_setup$X)
### lightweight script to fit hmmTMB
### on the energy dataset
library(hmmTMB)  ## requires first installing from github
library(MSwM)    ## package for data
data(energy)     ## load data
n_states <- 2    ## 2 states for now
### Create MarkovChain object
### Assume stationary distribution
hid <- MarkovChain$new(data = energy,
n_states = n_states,
stationary = TRUE)
### We want to model "Price" as a Gaussian,
### Parameters are mean and sd. There are
### over 20 named dists. to choose from.
### You could model more observed variables
### by adding them to the list.
dists <- list(Price = "norm")
### Create nested list of formulas
### The first layer has same names as dists
### The second layer are all of the parameters
### for each dist.
formulas <- list(Price = list(mean = ~s(Oil, k = 6, bs = "ps", m = c(2,1)),
sd = ~s(Oil, k = 6, bs = "ps", m = c(2,1))))
### Nested list of initial parameters
### of fixed effects/observation models.
pars <- list(Price = list(mean = rep(0, n_states), sd = rep(1, n_states)))
### Create observation model
obs <- Observation$new(data = energy, n_states = n_states, dists = dists,
par = pars, formulas = formulas)
### Example: get list of matrices and check
### that logdet(S) is well defined
obs_mats <- obs$make_mat()  ### get all matrices
S_list <- obs_mats$S_list   ### list of penalty matrices for each formula
obs_mats$S
obs_mats$S_list
gc()
gc()
for (i in 1:1000){
x = sample(3, seq(1, 12))
dist_temp = c(abs(x[1]-x[2]), abs(x[2]-x[3]))
dist[i] = mean(dist_temp)
}
n <- 1000
dist <- rep(0, 1000)
for (i in 1:1000){
x = sample(3, seq(1, 12))
dist_temp = c(abs(x[1]-x[2]), abs(x[2]-x[3]))
dist[i] = mean(dist_temp)
}
?sample
n <- 1000
dist <- rep(0, 1000)
for (i in 1:1000){
x = sample(seq(1, 12), 3)
dist_temp = c(abs(x[1]-x[2]), abs(x[2]-x[3]))
dist[i] = mean(dist_temp)
}
n <- 1000
dist <- rep(0, 1000)
for (i in 1:1000){
x = sample(seq(1, 12), 3)
dist_temp = c(abs(x[1]-x[2]), abs(x[2]-x[3]))
dist[i] = mean(dist_temp)
}
mean(dist)
x
dist_temp
sort(x)
n <- 1000
dist <- rep(0, 1000)
for (i in 1:1000){
x = sample(seq(1, 12), 3)
x = sort(x)
dist_temp = c(abs(x[1]-x[2]), abs(x[2]-x[3]))
dist[i] = mean(dist_temp)
}
mean(dist)
8 - 5 - 2
hist(dist)
n <- 1000
dist <- rep(0, 1000)
for (i in 1:1000){
x = sample(seq(1, 12), 3)
x = sort(x)
dist_temp = c(abs(x[1]-x[2]), abs(x[2]-x[3]))
dist[i] = mean(dist_temp)
}
median(dist)
?mod
?mean
mean(1,2)
n <- 1000
dist <- rep(0, 1000)
for (i in 1:1000){
x = sample(seq(1, 12), 3)
x = sort(x)
dist_1 = x[2]-x[1]
dist_2 = x[3]-x[2]
dist_3 = x[1]+12-x[3]
dist[i] = mean(c(dist_1,dist_2,dist_3))
}
median(dist)
hist(dist)
head(dist)
x
x = sample(seq(1, 12), 3)
x
x = sort(x)
x
dist_1 = x[2]-x[1]
dist_2 = x[3]-x[2]
dist_3 = x[1]+12-x[3]
dist_1
dist_2
dist_3
x = c(2,5,8)
dist_1 = x[2]-x[1]
dist_2 = x[3]-x[2]
dist_3 = x[1]+12-x[3]
mean(c(dist_1,dist_2,dist_3))
dist_1
dist_2
dist_3
library(knitr)
library(tidyverse)
library(GEOquery)
library(limma)
eset <- getGEO("GSE4051", getGPL = FALSE)[[1]]
eset
exprs(eset)[1:5,1:4]
str(pData(eset))
head(pData(eset)[,1:3])
pData(eset) <- pData(eset) %>%
mutate(sample_id = geo_accession) %>%
mutate(dev_stage =  case_when(
grepl("E16", title) ~ "E16",
grepl("P2", title) ~ "P2",
grepl("P6", title) ~ "P6",
grepl("P10", title) ~ "P10",
grepl("4 weeks", title) ~ "4_weeks"
)) %>%
mutate(genotype = case_when(
grepl("Nrl-ko", title) ~ "NrlKO",
grepl("wt", title) ~ "WT"
))
pData(eset) %>%
with(table(dev_stage, genotype))
pData(eset) <- pData(eset) %>%
mutate(dev_stage = fct_relevel(dev_stage, "E16", "P2", "P6", "P10", "4_weeks")) %>%
mutate(genotype = as.factor(genotype))
# note that Levels contain all possible categories of the variable, and are in the designated order
pData(eset)$dev_stage
pData(eset)$genotype
# number of samples in the expression matrix
ncol(exprs(eset))
# number of samples in the samples metadata
nrow(pData(eset))
# do these numbers match? Let's also print them out
exprs(eset) %>% colnames()
pData(eset)$sample_id
# do the samples match?
identical(exprs(eset) %>% colnames(),
pData(eset)$sample_id)
# transform into a format ggplot can easily work with
# we add row names (gene names) to a column, then
# we tell pivot_longer to transform all columns but gene
longExpressionMatrix <- exprs(eset) %>%
as.data.frame() %>%
rownames_to_column("gene") %>%
pivot_longer(cols = !gene,
values_to = "Expression",
names_to = "sample_id")
longExpressionMatrix
toLonger <- function(expressionMatrix) {
expressionMatrix <- longExpressionMatrix <- expressionMatrix %>%
as.data.frame() %>%
rownames_to_column("gene") %>%
pivot_longer(cols = !gene,
values_to = "Expression",
names_to = "sample_id")
return(expressionMatrix)
}
toLonger(exprs(eset))
toLonger(exprs(eset)) %>%
ggplot(aes(x = sample_id, y = Expression)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
toLonger(exprs(eset))  %>%
ggplot(aes(x = Expression, color = sample_id)) +
geom_density() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
geneIds <- c("1416119_at", "1431708_a_at")
# use dplyr::filter() to get the expression data for the gene
expressionDataForGene <- toLonger(exprs(eset)) %>%
filter(gene %in% geneIds)
expressionDataForGene <- expressionDataForGene %>%
left_join(pData(eset) %>% select(sample_id, dev_stage, genotype),
by = "sample_id")
expressionDataForGene
toLongerMeta <- function(expset) {
stopifnot(class(expset) == "ExpressionSet")
expressionMatrix <- longExpressionMatrix <- exprs(expset) %>%
as.data.frame() %>%
rownames_to_column("gene") %>%
pivot_longer(cols = !gene,
values_to = "Expression",
names_to = "sample_id") %>%
left_join(pData(expset) %>% select(sample_id, dev_stage, genotype),
by = "sample_id")
return(expressionMatrix)
}
toLongerMeta(eset)
expressionDataForGene %>%
ggplot(aes(x = Expression, y = genotype, color = genotype)) +
geom_point(size = 3, shape = 1) +
facet_wrap(~gene)
boringGene <- expressionDataForGene %>% filter(gene == "1416119_at")
t.test(Expression ~ genotype, boringGene)
interestingGene <- expressionDataForGene %>% filter(gene == "1431708_a_at")
t.test(Expression ~ genotype, interestingGene)
boringGene <- toLongerMeta(eset) %>% filter(gene == "1416119_at")
summary(lm(Expression ~ genotype, boringGene))
interestingGene <-  toLongerMeta(eset) %>% filter(gene == "1431708_a_at")
summary(lm(Expression ~ genotype, interestingGene))
interestingGene <- toLongerMeta(eset) %>% filter(gene == "1431708_a_at")
summary(aov(Expression ~ dev_stage, interestingGene))
interestingGene <- toLongerMeta(eset) %>% filter(gene == "1431708_a_at")
summary(lm(Expression ~ dev_stage, interestingGene))
set.seed(124)
numberOfGenes <- 1000
numberOfSamples <- 3
# each row is a gene, each column is a sample
simulatedGeneExpressionMatrix <- matrix(rnorm(numberOfGenes * numberOfSamples), nrow = numberOfGenes)
simulatedGeneExpressionMatrix %>% head()
geneVars <- simulatedGeneExpressionMatrix %>% apply(1, var) # work out the variance for each gene
tibble(variance = geneVars) %>%
ggplot(aes(x = variance)) +
geom_density() +
geom_point(aes(y = 0), shape = 1, size = 3)
# get tidy (long) table containing expression + metadata of wild type samples (useful for plotting later on)
wildType_long <- toLongerMeta(eset) %>%
filter(genotype == "WT")
# pull out just metadata for wildtype samples
wildTypeMetadata <- pData(eset) %>%
filter(genotype == "WT") %>%
select(sample_id, genotype, dev_stage)
# pull out just expression data for wildtype samples
# makes use of the fact that the eset has column (sample) names
wildTypeExpressionMatrix <- exprs(eset[, wildTypeMetadata$sample_id])
# Ordering of samples in the samples metadata
wildTypeMetadata$sample_id
# Ordering of samples in the expression matrix
colnames(wildTypeExpressionMatrix)
# check equivalence
identical(wildTypeMetadata$sample_id, colnames(wildTypeExpressionMatrix))
designMatrix <- model.matrix(~dev_stage, wildTypeMetadata)
head(designMatrix, 10) %>% kable()
head(wildTypeMetadata, 10) %>% kable()
# keep the fit around as we will need to it for looking at other contrasts later
wildTypeDevStageFit <- lmFit(wildTypeExpressionMatrix, designMatrix)
# run ebayes to calculate moderated t-statistics
wildTypeDevStageFitEb <- eBayes(wildTypeDevStageFit)
wildTypeDevStageFit_eset <- lmFit(eset[,wildTypeMetadata$sample_id],
designMatrix)
identical(wildTypeDevStageFit, wildTypeDevStageFit_eset)
topTenGenes <- topTable(wildTypeDevStageFitEb)
topTenGenes
topGenes <- rownames(topTenGenes)[1:6]
topGenesExpressionData <- toLongerMeta(eset) %>%
filter(genotype == "WT") %>%
filter(gene %in% topGenes)
topGenesExpressionData # reminder of formatted expression data looks like - for easy graphing
topGenesExpressionData %>%
ggplot(aes(x = dev_stage, y = Expression, color = genotype)) +
geom_point(shape = 1, size = 2) +
stat_summary(aes(y = Expression, group=1), fun = mean, geom="line") +
facet_wrap(~gene)
plotGenes <- function(genes, exprset) {
expressionDataForGenes <- toLongerMeta(exprset) %>%
filter(gene %in% genes)
expressionDataForGenes %>%
ggplot(aes(x = dev_stage, y = Expression, color = genotype)) +
geom_point(shape = 1, size = 2) +
stat_summary(aes(y = Expression, group=1), fun = mean, geom="line") +
facet_wrap(~gene)
}
# verify that the function works - note that we have to subset the eset to just wild type samples
# unless we want to plot all samples
plotGenes(topGenes, eset[, eset$genotype == "WT"])
allGenes <- topTable(wildTypeDevStageFitEb, number = Inf) # show all genes in the list, rather than just the top 10
nrow(allGenes) # number of genes
# Let's look at the bottom 6 genes
boringGeneIndices <- seq(from = nrow(allGenes), to = nrow(allGenes) - 5)
boringGenes <- allGenes[boringGeneIndices,]
# print out the boring genes and their p-values
boringGenes
plotGenes(rownames(boringGenes), eset[, eset$genotype == "WT"])
# construct the contrast matrix
contrastMatrix <- makeContrasts(
p10vsp6 = dev_stageP10 - dev_stageP6,
fourweeksVsP10 = dev_stage4_weeks - dev_stageP10,
levels = designMatrix
)
contrastMatrix # take a look
# fit the contrast using the original fitted model
contrastFit <- contrasts.fit(wildTypeDevStageFit, contrastMatrix)
# apply eBayes() for moderated statistics
contrastFitEb <- eBayes(contrastFit)
contrastGenes <- topTable(contrastFitEb)
contrastGenes
# again plot the top 6 genes
plotGenes(rownames(contrastGenes)[1:6], eset[, eset$genotype == "WT"])
cutoff <- 1e-04
wtResCont <- decideTests(contrastFitEb, p.value = cutoff, method = "global")
summary(wtResCont)
hits1 <- wtResCont %>%
as.data.frame() %>%
rownames_to_column("gene") %>%
filter(p10vsp6 < 0)
# these are the genes that declined from P6 to P10
hits1
# lets plot them
plotGenes(hits1$gene, eset[, eset$genotype == "WT"])
hits2 <- wtResCont %>%
as.data.frame() %>%
rownames_to_column("gene") %>%
filter(fourweeksVsP10 < 0)
# these are the genes that declined from P10 to 4_weeks
hits2
# lets plot them
plotGenes(hits2$gene[1:4], eset[, eset$genotype == "WT"])
hits1$gene %>% intersect(hits2$gene)
# for simplification, let's look at only a two-by-two design, we'll filter for developmental stages E16 and 4_weeks
interactionSamples <- pData(eset) %>%
filter(dev_stage %in% c("E16", "4_weeks")) %>%
select(sample_id, dev_stage, genotype)
# IMPORTANT - you want to adjust factor levels here to eliminate stages P2, P6, and P10 from your design matrix
interactionSamples$dev_stage <- interactionSamples$dev_stage %>%
as.character() %>%
factor(levels = c("E16", "4_weeks"))
# reminder of what samples metadata look like - all samples
interactionSamples
# construct the design matrix to include all groups for genotype and developmental stages plus the interaction terms
interactionDesign <- model.matrix(~genotype*dev_stage, interactionSamples)
interactionDesign
# first fit the model
interactionFit <- lmFit(eset[, interactionSamples$sample_id],
interactionDesign) %>% eBayes()
# make DE calls for each coefficient
de_calls <- decideTests(interactionFit, method = "global", cutoff = 1e-6) %>%
as.data.frame() %>%
rownames_to_column("gene") %>%
as_tibble()
# look for all genes with significant negative interaction effect and up regulation across developmental stages in KO (simple effect)
which.flip <- de_calls %>%
filter(dev_stage4_weeks > 0, `genotypeWT:dev_stage4_weeks` < 0) %>%
pull(gene)
# sort results by strength of interaction effect; pull out the genes with opposite
# developmental stage simple effect and interaction effect identified above
hits <- topTable(interactionFit, number = Inf,
coef = "genotypeWT:dev_stage4_weeks") %>%
rownames_to_column("gene") %>%
filter(gene %in% which.flip)
# lets try plotting 4 on this list
expressionDataForHits <- toLongerMeta(eset[, eset$sample_id %in% interactionSamples$sample_id]) %>%
filter(gene %in% hits$gene[1:4])
expressionDataForHits %>%
ggplot(aes(x = dev_stage, y = Expression, color = genotype)) +
geom_point(shape = 1, size = 2) +
stat_summary(aes(y = Expression, group = genotype), fun = mean, geom = "line") +
facet_wrap(~ gene)
de_calls
library(readr)
CPI_MONTHLY <- read_csv("Downloads/CPI_MONTHLY.csv",
col_types = cols(date = col_character()))
View(CPI_MONTHLY)
?strsplit
?separate
library(tidyverse)
?separate
CPI_MONTHLY <- CPI_MONTHLY |> separate_wider_delim(date, "-", names = c("year", "month", "date")) |>
filter(month == "4") |> select(year, V41690973)
CPI_MONTHLY
CPI_MONTHLY <- read_csv("Downloads/CPI_MONTHLY.csv",
col_types = cols(date = col_character()))
CPI_MONTHLY <- CPI_MONTHLY |> separate_wider_delim(date, "-", names = c("year", "month", "date")) |>
filter(month == 4) |> select(year, V41690973)
CPI_MONTHLY
CPI_MONTHLY <- CPI_MONTHLY |> separate_wider_delim(date, "-", names = c("year", "month", "date"))
CPI_MONTHLY <- read_csv("Downloads/CPI_MONTHLY.csv",
col_types = cols(date = col_character()))
CPI_MONTHLY <- CPI_MONTHLY |> separate_wider_delim(date, "-", names = c("year", "month", "date"))
CPI_MONTHLY
CPI_MONTHLY <- read_csv("Downloads/CPI_MONTHLY.csv",
col_types = cols(date = col_character()))
CPI_MONTHLY <- CPI_MONTHLY |> separate_wider_delim(date, "-", names = c("year", "month", "date")) |>
filter(month == "04") |> select(year, V41690973)
CPI_MONTHLY
CPI_MONTHLY <- read_csv("Downloads/CPI_MONTHLY.csv",
col_types = cols(date = col_character()))
CPI_MONTHLY <- CPI_MONTHLY |> separate_wider_delim(date, "-", names = c("year", "month", "date")) |>
filter(month == "04") |> select(year, V41690973)  |> mutate(year = as.numeric(year)) |>
filter(year > 2002)
CPI_MONTHLY
write_csv(CPI_MONTHLY, "CPI_Cleaned.csv")
setwd("~/Documents/random/nserc_stats")
data <- read_csv("data.csv")
View(data)
data
data |> ggplot(aes(x = PGSAward)) + geom_line()
data |> ggplot(aes(x = year, y = PGSAward)) + geom_line()
data |> ggplot(aes(x = Year, y = PGSAward)) + geom_line()
data |> ggplot(aes(x = Year, y = PGSAward)) + geom_line() + theme_light()
data |> ggplot(aes(x = Year, y = PGSAward)) + geom_line() + geom_line(y = CGSAward, color = "red") theme_light()
data |> ggplot(aes(x = Year, y = PGSAward)) + geom_line() + geom_line(y = CGSAward, color = "red") + theme_light()
data |> ggplot(aes(x = Year, y = PGSAward)) + geom_line() + theme_light()
data |> ggplot(aes(x = Year, y = TotalAwardValue)) + geom_line() + theme_light()
data |> ggplot(aes(x = Year, y = AppCorrected)) + geom_line() + theme_light()
data |> ggplot(aes(x = Year, y = EnrolCorrected)) + geom_line() + theme_light()
data |> ggplot(aes(x = Year, y = UBCPhDIntl)) + geom_line() + theme_light()
